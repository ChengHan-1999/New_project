#pragma once
#include"CGbase.h"
#include <d3d12.h>
struct STATIC_VERTEX
{
	Vec3 pos;
	Vec3 normal;
	Vec3 tangent;
	float tu;
	float tv;
};
class VertexLayoutCache
{
public:
	static const D3D12_INPUT_LAYOUT_DESC& getStaticLayout() {
		static const D3D12_INPUT_ELEMENT_DESC inputLayoutStatic[] = {
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT,
		D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT,
		D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT,
		D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT,
		D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		};
		static const D3D12_INPUT_LAYOUT_DESC desc = { inputLayoutStatic, 4 };  //
		return desc;
	}
	static D3D12_INPUT_LAYOUT_DESC getShadowInstancedLayout()  
	{
		static D3D12_INPUT_ELEMENT_DESC layout[] =
		{
			// Slot 0：Mesh vertex
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT,
			  0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },

			  // Slot 1：Instance world matrix
			  { "INSTANCE_W0", 0, DXGI_FORMAT_R32G32B32A32_FLOAT,
				1, 0,  D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1 },

			  { "INSTANCE_W1", 0, DXGI_FORMAT_R32G32B32A32_FLOAT,
				1, 16, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1 },

			  { "INSTANCE_W2", 0, DXGI_FORMAT_R32G32B32A32_FLOAT,
				1, 32, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1 },

			  { "INSTANCE_W3", 0, DXGI_FORMAT_R32G32B32A32_FLOAT,
				1, 48, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1 },
		};
		//我懂了你这个跟那个是一样的，这个就是同时在读两个槽位的顶点数据，一个是mesh的顶点数据，一个是实例化的矩阵数据，现在我要改成一个在读quad的顶点数据，另一个读每一个instance的中心位置和大小数据
		static D3D12_INPUT_LAYOUT_DESC desc =
		{
			layout,
			_countof(layout)
		};
		return desc;
	}
	static const D3D12_INPUT_LAYOUT_DESC& getAnimatedLayout()  //这个是用来获取动画网格的输入布局描述符的
	{
		static const D3D12_INPUT_ELEMENT_DESC inputLayoutAnimated[] =
		{
			/*{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },*/
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 0,
		  D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
			{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
			{ "TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
			{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
			{ "BONEIDS", 0, DXGI_FORMAT_R32G32B32A32_UINT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
			{ "BONEWEIGHTS", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },

		};
		static const D3D12_INPUT_LAYOUT_DESC desc = { inputLayoutAnimated, 6 };
		return desc;
	}
	static const D3D12_INPUT_LAYOUT_DESC& getStaticInstancedLayout() {  //这是用于实例化渲染的输入布局描述符
		static const D3D12_INPUT_ELEMENT_DESC layout[] = {
			// 顶点数据（和你现在 StaticLayout 一样）
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT,  
			  D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },//第2个0代表是从slot0来读取数据
			{ "NORMAL",   0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT,
			  D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }, //代表也是从slot0来读取数据
			{ "TANGENT",  0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D12_APPEND_ALIGNED_ELEMENT,
			  D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
			{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT,    0, D3D12_APPEND_ALIGNED_ELEMENT,
			  D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },

			  // 实例数据：World Matrix ，放到另一个buffer槽位，不在顶点初始化的时候 读取这个槽位
			  { "WORLD", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 0,  //这个代表是从slot1来读取数据，GPU是在IASetVertexBuffers的时候知道了哪个槽位绑定了哪个资源，然后按照规定的格式去解析数据
				D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1 },
			  { "WORLD", 1, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 16,
				D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1 },
			  { "WORLD", 2, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 32,
				D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1 },
			  { "WORLD", 3, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 48,
				D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1 },
		};
		static const D3D12_INPUT_LAYOUT_DESC desc = { layout, _countof(layout) };
		return desc;
	}
};



